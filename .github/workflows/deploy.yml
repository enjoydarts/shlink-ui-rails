# .github/workflows/deploy.yml
# æœ¬ç•ªç’°å¢ƒã¸ã®è‡ªå‹•ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
#
# å‹•ä½œæ¡ä»¶:
# - mainãƒ–ãƒ©ãƒ³ãƒã¸ã®push/mergeæ™‚ã«å®Ÿè¡Œ
# - Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’GitHub Container Registryã«ãƒ“ãƒ«ãƒ‰ãƒ»ãƒ—ãƒƒã‚·ãƒ¥
# - OCIã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã«SSHæ¥ç¶šã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤å®Ÿè¡Œ
# - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ãƒ»ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ä»˜ã

name: Production Deployment

# ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œæ¡ä»¶
on:
  push:
    branches: [main]
  workflow_dispatch:  # æ‰‹å‹•å®Ÿè¡Œã‚’è¨±å¯
    inputs:
      skip_tests:
        description: 'Skip test execution (emergency deploy)'
        required: false
        default: false
        type: boolean

# ç’°å¢ƒå¤‰æ•°è¨­å®š
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# ã‚¸ãƒ§ãƒ–å®šç¾©
jobs:
  # äº‹å‰ãƒã‚§ãƒƒã‚¯ã‚¸ãƒ§ãƒ–
  pre-checks:
    name: Pre-deployment checks
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      skip_tests: ${{ steps.check.outputs.skip_tests }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check deployment conditions
        id: check
        run: |
          # ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«[skip deploy]ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
          if git log -1 --pretty=%B | grep -q "\[skip deploy\]"; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "ğŸš« Deployment skipped due to [skip deploy] in commit message"
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "âœ… Deployment will proceed"
          fi

          # æ‰‹å‹•å®Ÿè¡Œæ™‚ã®ãƒ†ã‚¹ãƒˆã‚¹ã‚­ãƒƒãƒ—è¨­å®š
          if [[ "${{ github.event.inputs.skip_tests }}" == "true" ]]; then
            echo "skip_tests=true" >> $GITHUB_OUTPUT
            echo "âš ï¸  Tests will be skipped (emergency deploy)"
          else
            echo "skip_tests=false" >> $GITHUB_OUTPUT
          fi

  # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¸ãƒ§ãƒ–
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: pre-checks
    if: needs.pre-checks.outputs.should_deploy == 'true' && needs.pre-checks.outputs.skip_tests == 'false'

    # ã‚µãƒ¼ãƒ“ã‚¹ã‚³ãƒ³ãƒ†ãƒŠè¨­å®šï¼ˆãƒ†ã‚¹ãƒˆç”¨MySQL, Redisï¼‰
    services:
      mysql:
        image: mysql:8.4
        env:
          MYSQL_ROOT_PASSWORD: rootpass
          MYSQL_DATABASE: shlink_ui_rails_test
          MYSQL_USER: app
          MYSQL_PASSWORD: apppass
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: 3.4.5
          bundler-cache: true

      - name: Set up database
        env:
          RAILS_ENV: test
          DATABASE_HOST: 127.0.0.1
          DATABASE_NAME: shlink_ui_rails_test
          DATABASE_USER: app
          DATABASE_PASSWORD: apppass
          DATABASE_URL: mysql2://app:apppass@127.0.0.1:3306/shlink_ui_rails_test
          REDIS_URL: redis://localhost:6379/0
        run: |
          bin/rails db:create
          bundle exec ridgepole --config config/database.yml --env test --file db/schemas/Schemafile --apply

      - name: Precompile assets
        run: bundle exec rails assets:precompile

      - name: Run RuboCop
        run: bundle exec rubocop

      - name: Run RSpec
        env:
          RAILS_ENV: test
          DATABASE_URL: mysql2://app:apppass@127.0.0.1:3306/shlink_ui_rails_test
          REDIS_URL: redis://localhost:6379/0
        run: bundle exec rspec

  # Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ“ãƒ«ãƒ‰ãƒ»ãƒ—ãƒƒã‚·ãƒ¥ã‚¸ãƒ§ãƒ–
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: [pre-checks, test]
    if: needs.pre-checks.outputs.should_deploy == 'true' && (needs.test.result == 'success' || needs.pre-checks.outputs.skip_tests == 'true')
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
      tags: ${{ steps.meta.outputs.tags }}

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.production
          platforms: linux/arm64  # OCI Ampere A1ç”¨
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output image
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT

  # æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤ã‚¸ãƒ§ãƒ–
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-checks, build-and-push]
    if: needs.pre-checks.outputs.should_deploy == 'true'

    environment:
      name: production
      url: https://app.kty.at

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.OCI_SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${{ secrets.OCI_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment script
        run: |
          cat > deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -euo pipefail

          # è¨­å®š
          DEPLOY_TIMEOUT=600  # 10åˆ†
          HEALTH_CHECK_TIMEOUT=300  # 5åˆ†
          BACKUP_RETENTION_DAYS=7
          LOG_FILE="/opt/shlink-ui-rails/logs/deploy.log"

          # ãƒ­ã‚°é–¢æ•°
          log() {
            echo "$(date '+%Y-%m-%d %H:%M:%S'): $1" | tee -a "$LOG_FILE"
          }

          # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
          trap 'log "âŒ Deployment failed at line $LINENO"; exit 1' ERR

          log "ğŸš€ Starting deployment process..."

          # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ç§»å‹•
          cd /opt/shlink-ui-rails

          # ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
          if [ ! -f .env.production ]; then
            log "âŒ ERROR: .env.production file not found!"
            exit 1
          fi

          # GitHub Container Registryã«ãƒ­ã‚°ã‚¤ãƒ³
          log "ğŸ”‘ Logging into container registry..."
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
          log "ğŸ’¾ Creating backup of current containers..."
          BACKUP_TAG="backup-$(date +%Y%m%d-%H%M%S)"
          if docker-compose -f docker-compose.prod.yml ps -q app >/dev/null 2>&1; then
            RUNNING_CONTAINER=$(docker-compose -f docker-compose.prod.yml ps -q app)
            if [[ -n "$RUNNING_CONTAINER" ]]; then
              docker commit "$RUNNING_CONTAINER" "ghcr.io/${{ github.repository }}:$BACKUP_TAG" || log "âš ï¸  Backup creation failed"
            fi
          fi

          # æœ€æ–°ã®Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’å¼·åˆ¶ãƒ—ãƒ«
          log "ğŸ³ Pulling new Docker image: ${{ needs.build-and-push.outputs.image }}"
          docker pull ${{ needs.build-and-push.outputs.image }}
          docker tag ${{ needs.build-and-push.outputs.image }} ghcr.io/${{ github.repository }}:latest

          # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒã®é©ç”¨ï¼ˆRidgepoleï¼‰
          log "ğŸ—„ï¸  Applying database schema with Ridgepole..."
          docker-compose -f docker-compose.prod.yml run --rm app bundle exec ridgepole --config config/database.yml --env production --file db/schemas/Schemafile --apply

          # ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã®åˆæœŸåŒ–
          log "âš™ï¸  Initializing system settings..."
          docker-compose -f docker-compose.prod.yml run --rm app bundle exec rails runner "SystemSetting.initialize_defaults!"

          # ã‚µãƒ¼ãƒ“ã‚¹å†èµ·å‹•
          log "ğŸ”„ Restarting services with zero-downtime strategy..."
          docker-compose -f docker-compose.prod.yml up -d --force-recreate

          # ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å¾…æ©Ÿ
          log "ğŸ¥ Waiting for application to be healthy..."
          timeout $HEALTH_CHECK_TIMEOUT bash -c '
            while ! curl -sf http://localhost:3000/health >/dev/null 2>&1; do
              echo "â³ Waiting for health check..."
              sleep 10
            done
          ' || {
            log "âŒ Health check timeout! Rolling back..."
            # ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
            if [[ -n "${BACKUP_TAG:-}" ]] && docker image inspect "ghcr.io/${{ github.repository }}:$BACKUP_TAG" >/dev/null 2>&1; then
              log "ğŸ”„ Rolling back to previous version..."
              docker tag "ghcr.io/${{ github.repository }}:$BACKUP_TAG" "ghcr.io/${{ github.repository }}:latest"
              docker-compose -f docker-compose.prod.yml up -d --force-recreate
              sleep 30
              if curl -sf http://localhost:3000/health >/dev/null 2>&1; then
                log "âœ… Rollback successful"
              else
                log "âŒ Rollback also failed!"
              fi
            fi
            exit 1
          }

          log "âœ… Application is healthy!"

          # å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã¨ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          log "ğŸ§¹ Cleaning up old backups and images..."
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep "backup-" | \
            awk -v date="$(date -d "$BACKUP_RETENTION_DAYS days ago" +%Y-%m-%d)" '$2 < date {print $1}' | \
            xargs -r docker rmi || true

          docker system prune -f --filter "until=24h"

          # ãƒ‡ãƒ—ãƒ­ã‚¤æˆåŠŸãƒ­ã‚°
          log "ğŸ‰ Deployment completed successfully!"
          log "ğŸ“Š Image: ${{ needs.build-and-push.outputs.image }}"
          log "ğŸ”— Digest: ${{ needs.build-and-push.outputs.digest }}"
          echo "$(date): Deployment completed successfully - $(git -C app rev-parse --short HEAD)" >> deploy.log

          DEPLOY_SCRIPT

          chmod +x deploy.sh

      - name: Deploy to OCI
        env:
          IMAGE: ${{ needs.build-and-push.outputs.image }}
          DIGEST: ${{ needs.build-and-push.outputs.digest }}
        run: |
          scp -i ~/.ssh/id_ed25519 deploy.sh ${{ secrets.OCI_USERNAME }}@${{ secrets.OCI_HOST }}:/tmp/
          ssh -i ~/.ssh/id_ed25519 ${{ secrets.OCI_USERNAME }}@${{ secrets.OCI_HOST }} 'bash /tmp/deploy.sh && rm /tmp/deploy.sh'

      - name: Verify External Access
        run: |
          echo "ğŸ” Verifying external access..."
          timeout 300 bash -c '
            while ! curl -sf https://app.kty.at/health >/dev/null 2>&1; do
              echo "â³ Waiting for external access... ($(date))"
              sleep 15
            done
          '
          echo "âœ… External access verified!"

      - name: Post-deployment checks
        run: |
          echo "ğŸ” Running post-deployment checks..."

          # åŸºæœ¬ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://app.kty.at/health)
          if [[ "$HEALTH_STATUS" == "200" ]]; then
            echo "âœ… Health check passed (HTTP $HEALTH_STATUS)"
          else
            echo "âŒ Health check failed: HTTP $HEALTH_STATUS"
            exit 1
          fi

          # SSLè¨¼æ˜æ›¸ãƒã‚§ãƒƒã‚¯
          SSL_EXPIRE=$(echo | openssl s_client -connect app.kty.at:443 -servername app.kty.at 2>/dev/null | openssl x509 -noout -dates | grep notAfter | cut -d= -f2)
          echo "ğŸ” SSL certificate expires: $SSL_EXPIRE"

          # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ãƒã‚§ãƒƒã‚¯
          echo "ğŸ›¡ï¸  Security headers:"
          SECURITY_HEADERS=$(curl -sI https://app.kty.at/ | grep -E "(Strict-Transport-Security|X-Content-Type-Options|X-Frame-Options)" || echo "No security headers found")
          echo "$SECURITY_HEADERS"

          echo "ğŸŠ All post-deployment checks passed!"

  # ãƒ‡ãƒ—ãƒ­ã‚¤çŠ¶æ³é€šçŸ¥ã‚¸ãƒ§ãƒ–
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [pre-checks, test, build-and-push, deploy]
    if: always() && needs.pre-checks.outputs.should_deploy == 'true'

    steps:
      - name: Notify Success
        if: needs.deploy.result == 'success'
        run: |
          echo "ğŸ‰ Production deployment successful!"
          echo "ğŸŒ Application URL: https://app.kty.at"
          echo "ğŸ“Š Deployment time: $(date)"
          echo "ğŸ”— Commit: ${{ github.sha }}"
          # Slack/Discordé€šçŸ¥ãŒå¿…è¦ãªå ´åˆã¯ã“ã“ã«è¿½åŠ 

      - name: Notify Failure
        if: contains(needs.*.result, 'failure')
        run: |
          echo "âŒ Production deployment failed!"
          echo "ğŸ” Failed jobs:"
          echo "  - Test: ${{ needs.test.result }}"
          echo "  - Build: ${{ needs.build-and-push.result }}"
          echo "  - Deploy: ${{ needs.deploy.result }}"
          echo "ğŸ“‹ Check the workflow logs for details"
          echo "ğŸ¥ Health check URL: https://app.kty.at/health"
          # ç·Šæ€¥ã‚¢ãƒ©ãƒ¼ãƒˆãŒå¿…è¦ãªå ´åˆã¯ã“ã“ã«è¿½åŠ 

      - name: Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Result:** ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** https://app.kty.at" >> $GITHUB_STEP_SUMMARY
          echo "- **Time:** $(date)" >> $GITHUB_STEP_SUMMARY